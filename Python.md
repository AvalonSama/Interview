# Python

</br>

#### 多线程与GIL

- Python虚拟机使用一个**全局解释器锁**（Global Interpreter Lock）来互斥线程对Python虚拟机的使用。为了支持多线程机制，一个基本的要求就是需要实现不同线程对共享资源访问的互斥，所以引入了`GIL`。

- 在一个线程拥有了解释器的访问权之后，其他的所有线程都必须等待它释放解释器的访问权，即使这些线程的下一条指令并不会互相影响。

- GIL**缺点**：多处理器退化为单处理器；**优点**：避免大量的加锁解锁操作。

- 不管进程中有多少线程，**只有拿到了GIL锁的线程才可以在CPU上运行**，即使是多核处理器。对一个进程而言，不管有多少线程，任一时刻，只会有一个线程在执行。

</br>

#### 什么情况下适合使用多线程

- 对于**CPU密集型的线程**（各种循环处理、计数等等），多线程效率比较低，多进程效率高。

- 对于**IO密集型代码**（文件处理、网络爬虫等），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率）。

</br>

#### 生成器

- 直接创建一个包含大量元素的列表需要占用很大的存储空间。如果列表元素可以按照某种算法推算出来，那就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的列表，从而节省大量的空间。在Python中，**这种一边循环一边计算的机制，称为生成器**（Generator）。

- 生成器是一个特殊的程序，可以被用作控制循环的迭代行为，Python中**生成器是迭代器的一种，使用`yield`返回值函数**，每次调用`yield`会暂停，而可以使用`next()`函数和`send()`函数恢复生成器。生成器一次只能产生一个值，这样消耗的内存数量将大大减小。

  > [!TIP|label:创建生成器的方式]
  1. 生成器表达式</br>
    用括号而不是中括号创建的嵌套循环是生成器，如`generator_ex = (x*x for x in range(10))`，可以通过多次`next(generator_ex)`操作进行访问，但这样在遍历结束的时候再次调用`next()`会抛出异常。**更常规的方式是使用for循环**`for i in generator_ex`。
  2. 生成器函数</br>
    使用`yield`函数，在一个函数中的某一循环内，使用`yield`函数返回单次循环的某个计算结果（而不是全部计算完放在一个列表中`return`）。调用函数时也需要**使用for循环**，`yield`执行后函数会挂起，直到下一轮循环。

</br>

#### 迭代器

- 可以被`next()`函数调用并不断返回下一个值的对象称为**迭代器**（Iterator）。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器**只能往前不会后退**，它在正确的范围内返回期待的数据，在超出范围后能够抛出`StopIteration`的错误并停止迭代。

- 可以把迭代器这个数据流看做是一个有序序列，但却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以迭代器的计算是惰性的，**只有在需要返回下一个数据时它才会计算**。因此，**常见的可迭代对象**列表、字典、字符串**都不是迭代器**。

  > [!TIP|label:创建迭代器的方式]
  > 1. 把可迭代对象变成迭代器</br>
    采用`iter()`函数包裹可迭代对象，使它们变成迭代器。迭代器甚至可以表示一个无限大的数据流，例如全体自然数，而使用列表是永远不可能存储全体自然数的。
  > 2. 构造生成器</br>
    生成器本身就是一种迭代器，但是只可以读取它一次，因为用的时候才生成。
  > 3. 把类构造为迭代器</br>
    通过实现类的方法`__iter__()`使得类返回一个迭代器，再实现方法`__next__()`使得可以返回下一个迭代器对象。

</br>

#### 生成器和迭代器的区别

- **生成器是一个只能遍历一遍的特殊迭代器。**

- 生成器可以只使用`yield`关键字，而无需创建`iter()`和`next()`方法，显得特别简洁。

</br>

#### 闭包

- 如果在一个函数的内部定义了另一个函数，外部的函数叫它**外函数**，内部的函数叫它**内函数**。

- 闭包的条件
  1. 在一个外函数中定义了一个内函数；
  2. 内函数里运用了外函数的临时变量；
  3. 并且外函数的返回值是内函数的引用。

- 一般情况下，如果一个函数结束，函数的内部临时变量都会释放掉，还给内存。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就**把这个临时变量绑定给了内部函数**，然后自己再结束。

- 在闭包中如果需要修改闭包变量（外函数绑定给内函数的局部变量），可以用`nonlocal`声明。

</br>

#### 装饰器

- 装饰器（Decorators）就是用于拓展原来函数功能的一种函数，**目的是在不改变原函数名或内容的情况下，给函数增加新的功能**。装饰器可以让其他函数在不需要做任何代码变动的前提下**增加额外功能**，装饰器的返回值也是一个函数对象。通常抽离出来的功能是与函数功能本身无关的雷同代码并需要重用。

- 装饰器是建立在闭包的前提上的，因此装饰器满足闭包的条件。

  > [!TIP|label:创建迭代器的方式]
  > 1. 通过函数嵌套创建的装饰器</br>
  > ```python
    from functools import wraps
    def decorator_name(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            return f(*args, **kwargs)
        return decorated
    @decorator_name
    def func():
        return 1
  > ```
  > 2. 把类构造为装饰器</br>
  > ```python
    class decorator_name(object):
        def __init__(self, f):
            self.f = f
        def __call__(self, *args, **kwargs):
            self.f()
    @decorator_name
    def func():
        return 1
  > ```

</br>

#### 可变对象与不可变对象

- 在Python中，对对象有一种很通俗的说法，万物皆对象。说的就是构造的任何数据类型都是一个对象，无论是数字、字符串、还是函数，甚至是模块，Python都当做对象处理。

- 按更新对象的方式，可以将对象分为两大类：**可变对象**与**不可变对象**。

- 可变对象：列表、字典、集合。</br>
  所谓可变是指可变对象的值可变，身份（id）是不变的。

- 不可变对象：数字、字符串、元组。</br>
  不可变对象就是对象的身份和值都不可变。新创建的对象被关联到原来的变量名，旧对象被丢弃，垃圾回收器会在适当的时机回收这些对象。

</br>

#### 对象与引用

在Python中，每个对象都会在内存中申请开辟一块空间来保存该对象，**该对象在内存中所在位置的地址被称为引用**。在开发程序时，**变量就是地址的一种表示形式**，并不开辟开辟存储空间。

</br>

#### 元组是不可变的吗

- 元组是一个不可变对象，元组与列表最重要的区别就在于元组一经定义就不能改变其内容。

- 但是由于元组中存放的是对象的引用，**如果对象是一个可变对象，那该位置的对象是可变的**。

</br>

#### 深拷贝和浅拷贝

在Python中，**对象赋值实际上是对象的引用**。当创建一个对象，然后把它赋给另一个变量的时候，Python并没有拷贝这个对象，而只是拷贝了这个对象的引用。
