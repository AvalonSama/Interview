# 排序算法

</br>

| 排序    | 平均时间复杂度  | 最好情况      | 最坏情况      | 空间复杂度     | 稳定性 |
| :----: | :-----------: | :----------: | :----------: | :---------: | :----: |
| 插入排序 | $O(n^2)$     | $O(n)$       | $O(n^2)$     | $O(1)$       | 稳定   |
| 选择排序 | $O(n^2)$     | $O(n^2)$     | $O(n^2)$     | $O(1)$       | 稳定   |
| 冒泡排序 | $O(n^2)$     | $O(n)$       | $O(n^2)$     | $O(1)$       | 稳定   |
| 快速排序 | $O(n\log n)$ | $O(n\log n)$ | $O(n^2)$     | $O(n\log n)$ | 不稳定  |
| 归并排序 | $O(n\log n)$ | $O(n\log n)$ | $O(n\log n)$ | $O(n)$       | 稳定   |
| 计数排序 | $O(n+k)$     | $O(n+k)$     | $O(n+k)$     | $O(k)$       | 稳定   |
| 希尔排序 | $O(n)$       | $O(n^2)$     | $O(n^{1.3})$ | $O(1)$       | 不稳定  |
| 基数排序 | $O(nk)$      | $O(nk)$      | $O(nk)$      | $O(n+k)$     | 稳定   |
| 桶排序   | $O(n)$       | $O(n^2)$     | $O(n+k)$     | $O(n+k)$     | 稳定   |
| 堆排序   | $O(n\log n)$ | $O(n\log n)$ | $O(n\log n)$ | $O(1)$       | 不稳定 |

</br>

#### 插入排序

**思想：**对于第`i`个位置，认为前面的序列`0`到`i - 1`位置是已排好序的，向前寻找当前位置的数应该插入到哪个位置上，把大于该值的数往后挪。因此，从第`1`个位置开始扫描，而不是第`0`个。

<!-- tabs:start -->

##### **Python**

```python
def insert_sort(data: list):
    for i in range(1, len(data)):
        current = data[i]
        j = i - 1
        # 如果比当前值大，就往后挪
        while j >= 0 and data[j] > current:
            data[j + 1] = data[j]
            j -= 1
        data[j + 1] = current
    return data
```

##### **C++**

```cpp
vector<int> insert_sort(vector<int> data)
{
	int current, j;
	for(int i = 1; i < data.size(); i++)
	{
		current = data[i];
		j = i - 1;
		while(j >= 0 and current < data[j])
		{
			data[j + 1] = data[j];
			j--;
		}
		data[j + 1] = current;
	}
	return data;
}
```

<!-- tabs:end -->

</br>

#### 选择排序

**思想：**首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

<!-- tabs:start -->

##### **Python**

```python
def selection_sort(data: list):
    for i in range(len(data)):
        current_index = i
        for j in range(i + 1, len(data)):
            if data[j] < data[current_index]:
                current_index = j
        data[i], data[current_index] = data[current_index], data[i]
    return data
```

##### **C++**

```cpp
vector<int> selection_sort(vector<int> data)
{
	int current_index, temp;
	for(int i = 0; i < data.size(); i++)
	{
		current_index = i;
		for(int j = i + 1; j < data.size(); j++)
			if(data[j] < data[current_index])
				current_index = j;
		temp = data[i];
		data[i] = data[current_index];
		data[current_index] = temp;
	}
	return data;
}
```

<!-- tabs:end -->

</br>

#### 冒泡排序

**思想：**首先走一遍整个序列，对于位置`i`，如果该值大（小）于`i + 1`处的值，则交换，第一遍将最大（小）的元素交换到了序列末尾。重复这个过程，每次将未排序序列中最大（小）的元素放到未排序序列的末尾。

<!-- tabs:start -->

##### **Python**

```python
def bubble_sort(data):
    for i in range(len(data) - 1):
        did_swap = False
        for j in range(len(data) - i - 1):
            if data[j] > data[j + 1]:
                data[j], data[j + 1] = data[j + 1], data[j]
                did_swap = True
        if not did_swap:
            break
    return data
```

##### **C++**

```cpp
vector<int> bubble_sort(vector<int> data)
{
	int temp;
	bool did_swap;
	for(int i = 0; i < data.size() - 1; i++)
	{
		did_swap = false;
		for(int j = 0; j < data.size() - i - 1; j++)
			if(data[j + 1] < data[j])
			{
				temp = data[j];
				data[j] = data[j + 1];
				data[j + 1] = temp;
				did_swap = true;
			}
		if(!did_swap)
			break;
	}
	return data;
}
```

<!-- tabs:end -->

</br>

> [!NOTE|label:参考资料]
> [超详细十大经典排序算法总结](http://www.sohu.com/a/282433252_120045139)</br>