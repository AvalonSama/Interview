# 数组与链表

</br>

> [!NOTE|label:概念]
> - 数组</br>
>   1. **占据一块连续的内存并按照顺序存储数据**。
>   2. 需要预先指定数组大小，空间利用率较差。
>   3. 但可依据下标在`O(1)`时间内完成读写操作，时间效率比较高。
>   4. 简单hash表可利用数组下标为`key`值，数组中的元素为`value`值，完成`O(1)`时间内的查找。
> - 链表</br>
>  1. 动态数据结构，内存分配不是在创建链表时一次性完成的，空间效率比数组高。
>  2. 但查找第`i`个元素的操作需要`O(n)`，在末尾添加元素也需要`O(n)`的时间。

</br>


#### 题3 二维数组中的查找

**题目：**二维数组中，每行从左到右递增，每列从上到下递增，给出一个数，判断它是否在数组中。

<details>

<summary><b>解答</b></summary>

**思路：**从左下角或右上角开始比较。

```python
def find_integer(matrix, num):
    if not len(matrix):
        return False

    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1
    while row < rows and col >= 0:
        if matrix[row][col] == num:
            return True
        elif matrix[row][col] > num:
            col -= 1
        else:
            row += 1
    return False
```

</details>

</br>

#### 题5 从尾到头打印单链表

**题目：**输入一个链表的头节点，从尾到头反过来打印出每个节点的值。

<details>

<summary><b>解答</b></summary>

**方法一：**栈
```python
class LinkNode(object):
    def __init__(self, val):
        self.val = val
        self.next = None

def reverse_links(root):
    stack = []
    while root:
        stack.append(root.val)
        root = root.next
    while stack:
        print(stack.pop())
```

**方法二：**递归
```python
def reverse_links(root):
    if root:
        print_links(root.next)
        print(root.val)
```

</details>