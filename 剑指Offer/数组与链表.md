# 数组与链表

</br>

> [!NOTE|label:概念]
> - 数组</br>
>   1. **占据一块连续的内存并按照顺序存储数据**。
>   2. 需要预先指定数组大小，空间利用率较差。
>   3. 但可依据下标在`O(1)`时间内完成读写操作，时间效率比较高。
>   4. 简单hash表可利用数组下标为`key`值，数组中的元素为`value`值，完成`O(1)`时间内的查找。
> - 链表</br>
>  1. 动态数据结构，内存分配不是在创建链表时一次性完成的，空间效率比数组高。
>  2. 但查找第`i`个元素的操作需要`O(n)`，在末尾添加元素也需要`O(n)`的时间。

</br>

> [!TIP|label:构建一个方便测试的链表类]
> ```python
> class LinkNode(object):
>     def __init__(self, val: int):
>         self.val = val
>         self.next = None
>     #
>     def print(self):
>         pTemp = self
>         while pTemp:
>             print(pTemp.val, end=' ', flush=True)
>              pTemp = pTemp.next
>         print()
>     #
>     @classmethod
>     def build(cls, array: list) -> LinkNode:
>         pHead = pTemp = cls(None)
>         for a in array:
>             pTemp.next = LinkNode(a)
>             pTemp = pTemp.next
>         pHead = pHead.next
>         return pHead
> ```

</br>

#### 题3 二维数组中的查找

**题目：**二维数组中，每行从左到右递增，每列从上到下递增，给出一个数，判断它是否在数组中。

<details>

<summary><b>解答</b></summary>

**思路：**从左下角或右上角开始比较。

<!-- tabs:start -->

##### **Python**

```python
def find_integer(matrix: list, num: int) -> bool:
    if not len(matrix):
        return False

    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1
    while row < rows and col >= 0:
        if matrix[row][col] == num:
            return True
        elif matrix[row][col] > num:
            col -= 1
        else:
            row += 1
    return False
```

##### **C++**

```cpp
bool find_integer(int num, vector<vector<int> > matrix) {
    if(matrix.size() == 0)
        return false;
    int rows, cols;
    rows = matrix.size();
    cols = matrix[0].size();
    int row = 0, col = cols - 1;
    while(row < rows && col >= 0)
    {
        if(matrix[row][col] == num)
            return true;
        else if(matrix[row][col] > num)
            col--;
        else
            row++;
    }
    return false;
}
```

<!-- tabs:end -->

</details>

</br>

#### 题5 从尾到头打印单链表

**题目：**输入一个链表的头节点，从尾到头反过来打印出每个节点的值。

<details>

<summary><b>解答</b></summary>

**方法一：**栈
```python
def reverse_links(root: LinkNode) -> None:
    stack = []
    while root:
        stack.append(root.val)
        root = root.next
    while stack:
        print(stack.pop())
```

**方法二：**递归
```python
def reverse_links(root: LinkNode) -> None:
    if root:
        print_links(root.next)
        print(root.val)
```

</details>

</br>

#### 题8 用两个栈实现队列

**题目：**用两个栈实现队列，分别实现入队和出队操作。

<details>

<summary><b>解答</b></summary>

**思路：**一个栈负责入队，另一个负责出队，出栈为空则从入栈中导入到出栈中

```python
class MyQueue(object):
    def __init__(self):
        self.enstack = []
        self.destack = []

    def push(self, val):
        self.enstack.append(val)

    def pop(self):
        if self.destack:
            return self.destack.pop()
        while self.enstack:
            self.destack.append(self.enstack.pop())
        return self.destack.pop() if self.destack else None
```

</details>

</br>

#### 题9 旋转数组的最小数字

**题目：**把递增数组中前面的部分数字移到队尾，求数组中的最小值，例如`[3, 4, 5, 6, 1, 2]`。

<details>

<summary><b>解答</b></summary>

**思路：**使用二分法（时间复杂度`O(logn)`）。

> [!NOTE]
> 如果要考虑带重复数字的数据，只能顺序查找。

```python
def find_min(array: list) -> int:
    if len(array) < 1:
        return None

    left, right = 0, len(array) - 1
    middle = left
    while array[left] >= array[right]:
        if right - left == 1:
            middle = right
            break
        middle = (left + right) // 2
        if array[left] == array[middle] == array[right]:
            return min(array)
        if array[middle] >= array[left]:
            left = middle
        elif array[middle] <= array[right]:
            right = middle
    return array[middle]
```

</details>

</br>

#### 题10 矩阵中的路径

**题目：**请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左、右、上、下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

<details>

<summary><b>解答</b></summary>

**思路：**回溯法。定义一个布尔型矩阵标识该格子中的元素是否已经在路径中。

```python
n_row = len(matrix)
n_col = len(matrix[0])

def DFS(row: int, col: int, path: list, visited: list) -> bool:
    if len(path) == 0:
        return True
    if 0 <= row < n_row and 0 <= col < n_col and matrix[row][col] == path[0] and visited[row][col] == 0:
        visited[row][col] = 1
        flag = DFS(row + 1, col, path[1:], visited) or DFS(row - 1, col, path[1:], visited) \
               or DFS(row, col + 1, path[1:], visited) or DFS(row, col - 1, path[1:], visited)
        visited[row][col] = 0
        return flag
    return False

def has_path(matrix: list, path: list) -> bool:
    for row in range(n_row):
        for col in range(n_col):
            visited = [[0] * n_col for _ in range(n_row)]
            if DFS(row, col, path, visited):
                return True
    return False
```

</details>

</br>

#### 题11 机器人的运动范围

**题目：**地上有一个`m`行和`n`列的方格。一个机器人从坐标`(0, 0)`的格子开始移动，每一次只能向左、右、上、下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于`k`的格子。 请问该机器人能够达到多少个格子？

<details>

<summary><b>解答</b></summary>

**思路：**回溯法。定义一个布尔型矩阵标识该格子中的元素是否已经被访问过。

```python
n_row = len(matrix)
n_col = len(matrix[0])

def digit_sum(num: int) -> int:
    ssum = 0
    while num:
        ssum += num % 10
        num //= 10
    return ssum

def moving_count_core(visited: list, row: int, col: int, threshold: int) -> int:
    count = 0
    if 0 <= row < n_row and 0 <= col < n_col and visited[row * n_col + col] == 0 and (digit_sum(row) + digit_sum(col)) <= threshold:
        visited[row * n_col + col] = 1
        count = 1 + moving_count_core(visited, row - 1, col, threshold) + moving_count_core(visited, row + 1, col, threshold) \
                + moving_count_core(visited, row, col - 1, threshold) + moving_count_core(visited, row, col + 1, threshold)
    return count

def moving_count(threshold: int) -> int:
    if threshold < 0 or n_row <= 0 or n_col <= 0:
        return 0
    visited = [0] * n_col * n_row
    count = moving_count_core(visited, 0, 0, threshold)
    del visited
    return count
```

</details>

</br>

#### 题16 在O(1)时间内删除链表中节点

**题目：**给定单向链表的头指针和一个节点指针，定义一个函数在`O(1)`时间内删除该节点。

<details>

<summary><b>解答</b></summary>

**思路：**如果待删除结点指针有后继节点，则将**后继节点的值前移**后删除后继节点；否则顺序查找，删除待删除节点指针。

```python
def delete_node(pHead: LinkNode, pDelete: LinkNode) -> LinkNode:
    if pDelete.next:
        pnext = pDelete.next
        pDelete.val = pnext.val
        pDelete.next = pnext.next
        del pnext
    elif pHead == pDelete:
        pHead = None
        del pDelete
    else:
        pNode = pHead
        while pNode.next != pDelete:
            pNode = pNode.next
        pNode.next = None
        del pDelete
    return pHead
```

</details>

</br>

#### 题17 删除链表中重复的节点

**题目：**已排序的链表中，删除重复的节点。

<details>

<summary><b>解答</b></summary>

**思路：**在链表头节点添加一个值为空的节点，连续三个节点的值进行比较。

```python
def delete_duplication(pHead: LinkNode) -> LinkNode:
    p0 = LinkNode(None)
    p0.next = pHead
    p1, p2 = p0, p0
    while p2.next and p2.next.next:
        if p2.val != p2.next.val != p2.next.next.val:
            p1.next = p2.next
            p1 = p1.next
        p2 = p2.next
    if p2.next and p2.val != p2.next.val:
        p1.next = p2.next
    else:
        p1.next = None
    return p0.next
```

</details>

</br>