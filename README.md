# Python


#### 多线程

- Python虚拟机使用一个<font color=red>全局解释器锁</font>（Global Interpreter Lock）来互斥线程对Python虚拟机的使用。为了支持多线程机制，一个基本的要求就是需要实现不同线程对共享资源访问的互斥，所以引入了GIL。
- 在一个线程拥有了解释器的访问权之后，其他的所有线程都必须等待它释放解释器的访问权，即使这些线程的下一条指令并不会互相影响。
- GIL缺点：多处理器退化为单处理器；优点：避免大量的加锁解锁操作。
- 不管进程中有多少线程，只有拿到了GIL锁的线程才可以在CPU上运行，即使是多核处理器。对一个进程而言，不管有多少线程，任一时刻，只会有一个线程在执行。


#### 什么情况下适合使用多线程

- 对于CPU密集型的线程（各种循环处理、计数等等），多线程效率比较低，多进程效率高。
- 对于IO密集型代码（文件处理、网络爬虫等），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率）。


#### 生成器

- 直接创建一个包含大量元素的列表需要占用很大的存储空间。如果列表元素可以按照某种算法推算出来，那就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的列表，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。

- 生成器是一个特殊的程序，可以被用作控制循环的迭代行为，Python中生成器是迭代器的一种，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。生成器一次只能产生一个值，这样消耗的内存数量将大大减小。

- 创建生成器的方式
  1) 生成器表达式
  用括号而不是中括号创建的嵌套循环是生成器，如```generator_ex = (x*x for x in range(10))```，可以通过多次next(generator_ex)操作进行访问，但这样在遍历结束的时候再次调用next()会抛出异常。更常规的方式是使用for循环for i in generator_ex。

  2) 生成器函数
  使用yield函数，在一个函数中的某一循环内，使用yield函数返回单次循环的某个计算结果（而不是全部计算完放在一个列表中return）。调用函数时也需要使用for循环，yield执行后函数会挂起，直到下一轮循环。


#### 迭代器

- 可以被next()函数调用并不断返回下一个值的对象称为迭代器（Iterator）。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器只能往前不会后退，它在正确的范围内返回期待的数据，在超出范围后能够抛出StopIteration的错误并停止迭代。

- 可以把迭代器这个数据流看做是一个有序序列，但却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以迭代器的计算是惰性的，只有在需要返回下一个数据时它才会计算。因此，常见的可迭代对象列表、字典、字符串都不是迭代器。

- 创建迭代器的方式

  1) 把可迭代对象变成迭代器
  采用iter()函数包裹可迭代对象，使它们变成迭代器。迭代器甚至可以表示一个无限大的数据流，例如全体自然数，而使用列表是永远不可能存储全体自然数的。

  2) 构造生成器
  生成器本身就是一种迭代器，但是只可以读取它一次，因为用的时候才生成。

- 把类构造为迭代器
  __iter__()__next__()